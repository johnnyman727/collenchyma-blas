initSidebarItems({"mod":[["backend","Provides the interface for running parallel computations on one ore many devices.This is the abstraction over which you are interacting with your devices. You can create a backend for computation by first choosing a specifc Framework such as OpenCL and afterwards selecting one or many available hardwares to create a backend.A backend provides you with the functionality of managing the memory of the devices and copying your objects from host to devices and the other way around. Additionally you can execute operations in parallel through kernel functions on the device(s) of the backend.ArchitectureThe initialization of a backend happens through the BackendConfig, which defines which framework should be used and which programs should be available for parallel execution.Examples"],["binary","Provides the generic functionality for a backend-specific implementation of a library.A binary defines one or usually many operations, sharing related functionalities, which are provided by a specific library such as Blas.A binary needs to be 'build', which is handled at the specific framework implementation of a binary representation, and returns initialized operations based on a library.You are ususally not interacting with a binary itself, but rather use it to construct the backend-agnostic operations, which can then be run and parallelized via an unified interface - `backend.__name_of_the_operation__`.DevelopmentThe here provided funcionality is used to construct specific Collenchyma binaries, which are used to construct the basic computation behavior that come shipped with Collenchyma, but should allows you to define and run your own backend-agnostic programs as well."],["device","Provides a representation for one or many ready to use hardwares.Devices are a set of hardwares, which got initialized from the framework, in order that they are ready to receive kernel executions, event processing, memory synchronization, etc. You can turn available hardware into a device, through the backend."],["error","Defines the general set of error types in Collenchyma."],["framework","Provides the generic functionality of a hardware supporting frameworks such as native CPU, OpenCL, CUDA, etc..The default Framework would be plain host CPU for common computation. To make use of other computation hardwares such as GPUs you would choose other computation Frameworks such as OpenCL or CUDA, which provide the access to those hardwares for computation.To start backend-agnostic and highly parallel computation, you start by initializing on of the Framework implementations, resulting in an initialized Framework, that contains among other things, a list of all available hardwares through that framework.Examples"],["frameworks","Exposes the specific Framework implementations."],["hardware","Provides a representation for a collection of available compute units e.g. CPUs or GPUs.Hardware can be GPUs, multi-core CPUs or DSPs, Cell/B.E. processor or whatever else is supported by the provided frameworks such as OpenCL, CUDA, etc. The struct holds all important information about the hardware. To execute code on hardware, turn hardware into a device."],["memory","Provides a representation for memory across different frameworks.Memory is allocated by a device in a way that it is accessible for its computations.Normally you will want to use SharedMemory which handles synchronization of the latest memory copy to the required device."],["operation","Provides the generic functionality for backend-agnostic operations.An Operation describes the execution of a library provided functionality for a specific framework. An Operation can easily be executed in parallel on multi-core devices. An Operation is a very similar to a usual function and defines usually one or many arguments over which the operation then will happen.You are usually not interaction with an operation directly. To execute an operation you would use the backend. Also you usually will not initialize your operations directly, this happens usually automatically at the initialization of a binary.DevelopmentThe here provided functionality is used to construct specific Collenchyma operations, which are The functionality provided by this module is used to construct the basic operations that come shipped with Collenchyma, but should also allow you to define and run your own backend-agnostic operations as well."],["plugin","Provides helpers for explicit implementations of Backend Operations.A Backend is a Rust struct like any other, therefore you probably would like to implement certain methods for the Backend. As the whole purpose of a Backend is to provide an abstraction over various computation devices and computation languages, these implemented methods will than be able to excute on different devices and use the full power of the machine's underlying hardware.So extending the Backend with operations is easy. In Collenchyma we call crates, which provide operations for the Backend, Plugins. Plugins are usually a group of related operations of a common field. Two examples for Collenchyma Plugins are BLAS and [NN][ollenchyma-nn].A Plugin does roughly two important things. It provides generic traits and the explicit implementation of these traits for one or (even better) all available Collenchyma Frameworks - common host CPU, OpenCL, CUDA.The structure of Plugin is pretty easy with as less overhead as possible. Macros make implementations even easier. If you would like to use specific Plugins for you Backend, all you need to do is, setting them as dependencies in your Cargo file in addition to the Collenchyma crate. The Plugin then automatically extends the Backend provided by Collenchyma.If you would like to extend the Backend with your own Plugin, than this is a straight forward process. For now we recommend that you take a look at the general code structure of Collenchyma-BLAS or its documentation. Let us now about your Plugin on the Gitter chat, we are happy to feature your Collenchyma Plugin on the README."],["prelude","A module meant to be glob imported when using Collenchyma.For instance:This module contains several important traits that provide many of the convenience methods in Collenchyma, as well as most important types. Another type that is often needed but is likely to cause a name collision when imported is `collenchyma::Error`."],["tensor","Provides the functionality for memory management across devices.A Tensor is a potentially multi-dimensional matrix containing information about the actual data and it's structure. A Collenchyma Tensor tracks the memory copies of the numeric data of an Tensor across the devices of the Backend and managesthe location of these memory copies the location of the latest memory copy and the synchronisation of memory copies between devices This is important, as this provides a unified data interface for exectuing Tensor operations on CUDA, OpenCL and common host CPU.A memory copy represents one logical unit of data, which might me located at the host. The Tensor, tracks the location of the data blob across the various devices that the backend might consist of. This allows us to run operations on various backends with the same data blob.TerminologyA Tensor is a homogeneous multi-dimensional array - a table of elements (usually numeric elements) of the same type, indexed by tuples of positive integers. In Collenchyma `dimensions` of a Tensor describe what axis are for a coordinate system. The numbers of dimensions is the `rank`. A scala value like `3` has the rank 0, and a Rust array like `[1, 2, 3]` has a rank of 1 as it has one dimension. A array of arrays like `[[1, 2, 3], [2, 3]]` has a rank of 2 as it has two dimensions. The number of elements for a dimension is called `length`. And the number of all elements for each dimension summed up is the `size`. These meta data about a Tensor is called the `descriptor` of the Tensor.ExamplesCreate a SharedTensor and fill it with some numbers:"]]});